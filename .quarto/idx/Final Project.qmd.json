{"title":"Final Project: Data Science Culmination Project","markdown":{"yaml":{"title":"Final Project: Data Science Culmination Project","author":"Josh Miller & Elijah Hill","format":"html"},"headingText":"Introduction:","containsRefs":false,"markdown":"\n\n```{r custom_theme, results = \"hide\"}\nlibrary(tidyverse)\nstyled <-\n  theme_bw() + \n  theme(\n    plot.title = element_text(face = \"bold\", size = 12),\n    legend.background = element_rect(\n      fill = \"white\", \n      linewidth = 4, \n      colour = \"white\"\n    ),\n    axis.ticks = element_line(colour = \"grey70\", linewidth = 0.2),\n    panel.grid.major = element_line(colour = \"grey70\", linewidth = 0.2),\n    panel.grid.minor = element_blank()\n  )\n```\n\n```{r packages, results = \"hide\"}\nlibrary(\"tidymodels\") ; theme_set(styled)\nlibrary(\"janitor\")\nlibrary(\"olsrr\")\nlibrary(\"doParallel\")\nlibrary(\"dplyr\")\nlibrary(\"kernlab\")\nlibrary(\"rpart.plot\")\nlibrary(\"glmnet\")\nlibrary(\"GGally\")\nlibrary(\"cowplot\")\nlibrary(\"jtools\")\nlibrary(\"caret\")\n```\n\n```{r cores}\nall_cores <- parallel::detectCores(logical = FALSE)\ncl <- makePSOCKcluster(all_cores)\nregisterDoParallel(cl)\n```\n\n\nFor our Final Project, the dataset we decided to use was titled Salary by Job Title and Country. We found the dataset from Kaggle.com.\n\n<https://www.kaggle.com/datasets/amirmahdiabbootalebi/salary-by-job-title-and-country/data>\n\nThe dataset creator sourced this data from reputable employment websites and surveys, leaving out names and companies to ensure privacy for both parties.\n\n```{r dataset}\nSalary <- read_csv(\"Salary.csv\")\n```\n\nThere are 9 variables in the data, with 6684 observations. The variables are as follows: Age, Gender, Education Level, Job Title, Years of Experience, Salary, Country, Race, and Senior. Education level is encoded from 0-3, 0 meaning the employee has a high school diploma as their highest level of education, 1 meaning that they have a Bachelor's degree, 2 meaning they have a Master's, and 3 meaning they have a Doctorate's. The senior variable is a binary value indicating whether or not they have a senior-level position. Salary has been converted into USD for all countries for the sake of being on the same scale.\n\n```{r}\nhead(Salary)\n```\n\n# Questions and Goals:\n\nOur main question we wanted to answer was \"Can we accurately predict the salary of a job given the predictors in this data set\", those being Age, Senior, Country, Race, Job Title, Gender, and Education Level. We also wanted to explore the roles each of the predictors play in determining Salary. Some secondary questions we asked to determine this during our EDA were: \"Is one gender more often lower-paid than another?\", \"Does an increase in age usually lead to an increase in salary?\", \"How big a difference does a job being a senior position make on average to Salary?\", and more to go along with that: \"Are older people more likely to be the ones occupying senior positions?\". Whether or not the Education Level or Country of the job seems to give access to a higher salary were also questions we asked and found answers to.\n\n# **Preprocessing:**\n\nFor preprocessing, we quickly found 2 issues: First, we realized that certain job titles only appear once in the entire data set, one of the most notable being CEO. While this had one of the largest values for salary in the entire dataset, we realized that this would not only skew our EDA but would also cause problems for our testing and training splits later on. Therefore, we decided to drop them.\n\nWe then found an issue with values that were likely misreported within the dataset. Upon analyzing the bottom-most values for annual salary in the dataset, we found multiple employees reported only making 3 figures with jobs that in every other case paid well above that, such as Software Engineer Manager. We could be making a large assumption here that this was a full-time position being paid a yearly salary, but even if these values were correctly recorded, it would still be inconsistent with the rest of the dataset and cause a skew in the lowest-paying jobs.\n\n```{r}\n##PREPROCESSING\n\n#removing any job only included once \nSalary_cleaned <- Salary %>%\n  group_by(`Job Title`) %>%\n  mutate(\n    count = n()\n  ) %>%\n  filter(count > 1) %>%\n  ungroup() %>%\n  select(-count)\n#dropping probable mistaken entries (reported less than 1k salaries)\nSalary_cleaned <- Salary_cleaned %>%\n  arrange(Salary) %>%\n  filter(!row_number() %in% c(1,2,3,4))\n```\n\n# **EDA:**\n\n## Exploring Gender:\n\nWe wanted to explore if Females still earned less than men on average, as they have historically, so we first looked at a general average of all salaries of men versus those of women.\n\n```{r}\n#EDA (Gender)\n\n##GENDER DIFFERENCES\nSalary_cleaned_by_gender <- Salary_cleaned %>%\n  group_by(Gender) %>%\n    summarize(Mean = mean(Salary, na.rm = TRUE))\n#On average, women earn less than men\n\nSalary_cleaned_by_gender\n```\n\nThis table shows a sizable difference (about 19000) in the average salary of a male over one of a female, supporting our initial theory. We then split up the data to more deeply delve into the differences in pay between the two Genders.\n\n```{r}\n#Splitting salary into male and female\nsalary_male <- Salary_cleaned %>%\n  group_by(Gender) %>%\n    filter(Gender == \"Male\")\n\nsalary_female <- Salary_cleaned %>%\n  group_by(Gender) %>%\n    filter(Gender == \"Female\")\n```\n\nAfter splitting the data, we tried making four plots showing the top 15 highest-salary jobs and the bottom 15 lowest-salary jobs for comparison.\n\n```{r}\n# #comparing highest/lowest earning male/female jobs\n#  top_male_salaries <- salary_male %>%\n#  arrange(desc(Salary)) %>%\n#    slice(1:15)\n#  \n#  #ignoring mistaken entries (1 and 2 row)\n#  bottom_male_salaries <- salary_male %>%\n#  arrange(Salary) %>%\n#    slice(3:17)\n#  \n#  top_female_salaries <- salary_female %>%\n#  arrange(desc(Salary)) %>%\n#  slice(1:15)\n#  \n# #ignoring mistaken entries (1 and 2 row)\n#  bottom_female_salaries <- salary_female %>%\n#  arrange(Salary) %>%\n#    slice(3:17)\n\n#plots\n#tms_plot <- ggplot(top_male_salaries, aes(x = Salary)) +       #geom_bar(fill = \"blue\") +\n#theme_light()\n\n#bms_plot <- ggplot(bottom_male_salaries, aes(x = Salary)) +\n# geom_bar(fill = \"turquoise2\") +\n# theme_dark()\n\n#the above plots don't look good...\n#they are mostly the same jobs\n\n#trying again but with...\n```\n\nthe above plots don't look good... they are mostly the same jobs trying again but with averaging jobs with the same title together.\n\nUpon making the first few plots, we realized that the above plots did not look good as they were mostly showing the same job titles' salaries repeated multiple times. We remade the graphs but this time combined the job titles to eliminate repeated Job Titles. First, we made new tables to use with a new Average_Salary column for each job title, then eliminated other columns and rows besides unique Average_Salaries and Job Titles since those were what we were focusing on.\n\n```{r}\n#averaging jobs with the same title together\nsalary_male_unique <- salary_male %>%\n  group_by(`Job Title`) %>%\n  mutate(Average_Salary = mean(Salary)) %>%\n  distinct(Average_Salary)\n  \nsalary_female_unique <- salary_female %>%\n  group_by(`Job Title`) %>%\n  mutate(Average_Salary = mean(Salary)) %>%\n  distinct(Average_Salary)\n\nsalary_male_unique\nsalary_female_unique\n```\n\n```{r}\n#comparing highest/lowest earning male/female jobs\ntop_male_salaries_unique <- \n  salary_male_unique %>%\n  ungroup() %>% arrange(desc(Average_Salary)) %>% slice(1:10)\n\nbottom_male_salaries_unique <- \n  salary_male_unique %>%\n  ungroup() %>% \n  arrange(Average_Salary) %>% \n  slice(1:10)\n\ntop_female_salaries_unique <- \n  salary_female_unique %>%\n  ungroup() %>% \n  arrange(desc(Average_Salary)) %>% slice(1:10)\n\nbottom_female_salaries_unique <- \n  salary_female_unique %>%\n  ungroup %>%\n  arrange(Average_Salary) %>%\n    slice(1:10)\n\ntop_male_salaries_unique \nbottom_male_salaries_unique\ntop_female_salaries_unique\nbottom_female_salaries_unique\n```\n\nWe made the plots again, making sure to standardize the x-axis values to more clearly show any differences in pay. We made male plots blue, and female red, top salary plots have a light theme, and bottom salary plots use the dark theme to differentiate and help show the comparisons we were looking for.\n\n```{r}\ntms_plot <- ggplot(top_male_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"blue\") + \n    labs(y = \"Job Count\", x = \"Average Salary (Male)\") +\n    xlim(150000, 250000)\n```\n\n```{r}\nbms_plot <- ggplot(bottom_male_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"turquoise2\", bins = 40) +\n    labs(y = \"Job Count\", x = \"Average Salary (Male)\") +\n    xlim(24000, 58000)+ ylim(0, 3) + theme_dark()\n```\n\n```{r}\ntfs_plot <- ggplot(top_female_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"red\") +\n    labs(y = \"Job Count\", x = \"Average Salary (Female)\") +\n    xlim(150000, 250000)\n```\n\n```{r}\nbfs_plot <- ggplot(bottom_female_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"lightcoral\") +\n    labs(y = \"Job Count\", x = \"Average Salary (Female)\") +\n    xlim(24000, 58000) + ylim(0, 3) + theme_dark()\n```\n\nWe used the \"cowplot\" package to easily combine all four plots into one graphic for a more complete visual comparison of gender salary differences on the poles of the data.\n\n```{r}\nplot_grid(tms_plot, bms_plot, tfs_plot, bfs_plot, nrow = 2, ncol = 2)\n```\n\nAfter doing this, we realized that we could do almost the same thing, but in a broader sense (as well as faster), by just using a box plot.\n\n```{r}\n#comparing all salaries\nggplot(Salary_cleaned, aes(x = Salary, y = Gender)) +\n    geom_boxplot(aes(\n        fill = as.factor(`Gender`))) +\n    scale_color_manual(values = c(\"blue\", \"red\")) +\n    theme(legend.position = \"none\")\n```\n\nThe box plots, as well as the four plots prior, all point to what we had guessed which was that males do indeed earn higher salaries than females on average.\n\n## Exploring Education Level:\n\nNext, we examined the role education level played on salary amount. This time, we started with the general plot comparing all salaries grouped by Education Level, then moved on to showing the average salary of each Education Level after that.\n\n```{r}\n#EDA (Education Level)\n\nggplot(Salary_cleaned, aes(y = Salary,\n                           x = as.factor(`Education Level`),\n                           fill = as.factor(`Education Level`\n                                            )))+\n    scale_color_manual(values = c(\"red\", \"green\", \"yellow\", \"darkorchid3\")) +\n    labs(x = \"Education Level\") + \n    geom_boxplot() +\n    theme(legend.position = \"none\")\n\nsalary_by_ed_lvl <- Salary_cleaned %>%\n  group_by(`Education Level`) %>%\n  summarize(Mean = mean(Salary))\n\nggplot(salary_by_ed_lvl, aes(x = `Education Level`,\n                             y = Mean,\n                             fill = as.factor(\n                                 `Education Level`\n                                 ))) +\n    scale_color_manual(values = c(\"red\", \"green\", \"yellow\", \"darkorchid3\" )) + \n    labs(y = \"Mean Salary\") +\n    geom_col() +\n    theme(legend.position = \"none\")\n```\n\nWe were pleased to see not only that the data seemed to indicate that going to college is indeed still worth it, but that the data was nice and linear as well for both the raw and the average salary by education level comparisons.\n\n## Exploring Age and Seniority:\n\nAge and Seniority were two predictors we were especially excited to look at, and we had high expectations on the strength of the correlation between them and the salaries those of high age and in senior positions would hold. Once again, we showed a general plot using the raw salary data when compared with Age, this time using whether or not the job holder had the Senior status to determine the color of the plot point. After getting a nice-looking scatter plot from that (and being very happy with the color palette), we could see that there was some positive correlation between the age of a person, whether or not they would be in a senior position, and their salary. To get a slightly different perspective, we grouped the ages by decade and compared each Age Group's average salary to each other, and were once again satisfied to see a seemingly linear relationship between Age and Salary.\n\n```{r}\n#EDA (Age/Seniority)\nggplot(Salary_cleaned, aes(y = Salary, x = Age, color = as.factor(Senior))) +\n    scale_color_manual(values = c(\"ivory4\", \"goldenrod\"),\n                       labels = c(\"Non-Senior Position\", \n                                  \"Senior\")) +\n    labs(color = \"Seniority\") + geom_point()\n\nsalary_by_age <- Salary_cleaned %>%\n  mutate(Age_Group = case_when(\n    Age < 30 ~ \"29 & Younger\",\n    Age < 40 & Age >= 30 ~ \"30's\",\n    Age < 50 & Age >= 40 ~ \"40's\",\n    Age < 60 & Age >= 50 ~ \"50's\",\n    Age >= 60 ~ \"60 & Older\"\n  )) %>% \n  group_by(Age_Group) %>%\n  summarize(Average_Salary = mean(Salary))\n\nggplot(salary_by_age, aes(x = Age_Group,\n                          y = Average_Salary,\n                          fill = as.factor(Age_Group)),) +\n    scale_fill_manual(values = c(\"ivory4\",\"grey\",\n                                 \"lightgoldenrod2\",\n                                 \"goldenrod2\",\n                                 \"goldenrod3\")) +\n    geom_col() +\n    theme(legend.position = \"none\",\n                       panel.background = element_rect(fill = \"slategray3\")) +\n    labs(x = \"Age Group\", y = \"Average Salary\")\n```\n\n## Exploring Country and Race:\n\nThe first thing we did to look at Country and Race was to use multilevel grouping to get a better understanding of the demographics of the data. After noting the variety of Races in each Country, we proceeded to make a violin plot comparing the Salaries of those living in different Countries. That plot did not look great, so we reverted to using box plots for comparing Races' Salary earnings. The main takeaway we received from these two plots was that the Country and Race of a person do not seem to be significant factors in determining one's salary.\n\n```{r}\n#EDA (Country/Race)\nSalary_cleaned %>% \n  group_by(Country, Race) %>%\n  summarize(count = n())\n\nggplot(Salary_cleaned, aes(x = Salary, y = Country, fill = as.factor(Country))) + \n    scale_fill_manual(values = c(\"red\", \"white\", \"gold\", \"purple\", \"blue\")) +\n    geom_violin() +\n    theme(legend.position = \"none\")\n\nggplot(Salary_cleaned, aes(x = Salary, y = Race, color =  as.factor(Race))) +\n    geom_boxplot() +\n    theme(legend.position = \"none\")\n\n```\n\n## Exploring Job Title:\n\nWhen thinking of what to explore with Job Titles, we were at first a little unsure of what to compare, since there were so many unique Job Titles in the data. We ended up simply making a table of the top 10 highest-salary jobs and the \"top 10\" lowest-salary jobs.\n\n```{r}\n#EDA (Job Title)\n#hrm...\nsalary_by_job_title <- Salary_cleaned %>%\n  group_by(`Job Title`) %>%\n  mutate(Average_Salary = mean(Salary)) %>%\n  distinct(Average_Salary)\n\ntop_jobs <- salary_by_job_title %>%\n  ungroup() %>%\n  arrange(desc(Average_Salary)) %>%\n  slice(1:10)\n\nworst_jobs <- salary_by_job_title %>%\n  ungroup() %>%\n  arrange(Average_Salary) %>%\n  slice(1:10)\n\ntop_jobs\nworst_jobs\n```\n\nOne interesting thing that we could see from these tables is that Job Titles with \"Director\" and \"Engineer\" are featured frequently in the higher end of the Salary data. This could either be an insight into the types of jobs that give high Salaries, or the types of jobs that the data was scraped from. Either way, the wide range of names meant that job titles were most likely going to be largely ineffective as a predictor for our models.\n\n# Modeling:\n\nNow that we have gathered some insights about this data as well as having answered our minor questions from our exploratory analysis, we will use modeling to answer our main question.\n\nBefore we get into creating the models, we will split the salary dataset into a training and testing data frame, using a 90/10 proportion respectively.\n\n```{r}\nsalary_split <- initial_split(Salary_cleaned, prop = 0.90)\ntraining <-training(salary_split)\ntesting <- testing(salary_split)\n```\n\nTo create a ridge regression model, we need to turn all of our datasets into numeric factors. We will get to the ridge regression model later. This is simply up here for rendering reasons.\n\n```{r}\nridge_salary <- Salary_cleaned %>%\n  transform(.,\n                   Race = as.numeric(as.factor(Race)),\n                   Country = as.numeric(as.factor(Country)),\n                   `Job Title` = as.numeric(as.factor(`Job Title`)),\n                   Gender = as.numeric(as.factor(Gender)))\nridge_split <- initial_split(ridge_salary, prop = .90)\ntrain <- training(ridge_split)\ntest <- testing(ridge_split)\n\n```\n\n## Multiple Linear Regression:\n\nNow that we split the data into training and testing, we will create our first model: a multiple linear regression model. A multiple linear regression model is simple, yet it can still give a good benchmark for comparisons to our other models.\n\n```{r}\nfit <- lm(Salary ~ ., data = training)\nsummary(fit)\n```\n\nAs we can see, the most significant predictors are education level, years of experience, and senior, all of which make sense as it is logical that the more years of experience you have in a profession and the higher level of education you have, the more likely you are going to earn more money than someone who has less experience and a lesser degree. Seniority also makes sense as a senior-level position undoubtedly has more responsibilities than someone who isn't. However, we can see that several job title codes are good indicators. Jobs such as software engineer, research scientist, research director, product manager, and data scientist/analyst all appear to be very good predictors for our model. This may well be because there are simply more observations of these job titles in the data set, but all of these fields are certainly very highly-paying positions. Now, to look at the results. We can see that the model generated an R-squared value of .82, on an F-stat of 296.3, and a p-value of \\<2.2e-16, so needless to say, this is a respectable model; it is not perfect, but there is a strong positive correlation between the predictors and Salary.\n\nBefore we go any further, we should check the assumptions of our model to see if this dataset even can be fitted into a linear model.\n\n```{r}\npar(mfrow = c(2,2))\nplot(fit)\n```\n\nChecking the normal assumptions of linear regression, we can see that the data appears to fit to an acceptable level. The residuals vs. Fitted values graph is distributed mostly evenly from end to end, and the Q-Q Residuals plot, while both tails do slightly veer off the mean, they do at least mirror each other.\n\nNow let us fit this model into our testing data. As you can see, we bound the predicted outcomes onto the testing dataset so we can compare the predicted value to the employee's actual salary.\n\n```{r}\nlm_preds <- predict(fit, testing) %>%\n  bind_cols(testing)\nlm_preds\n```\n\nWhile the predictions are not perfect, the model does get rather close to predicting the salary of some employees, with some predictions getting even within 1000 dollars of the actual value. However, it is not perfect, so let's tune the model to see if we can improve the accuracy.\n\nLet us try to optimize the model by running a step-forward selection model to see what variables it would choose to use.\n\n```{r}\nols_step_forward_p(fit)\n```\n\nUnsurprisingly, the summary has chosen the variables that I had highlighted in the original model. Interestingly, this model scraps Gender, Race, and Country; it does not consider them strong enough to influence the model.\n\nNow that we've figured out the ideal variables for the model, let's create a new model to see if we can improve the accuracy by removing unnecessary predictors:\n\n```{r}\nstep_fit <- \n    lm(Salary ~ Age + `Education Level` +\n           `Years of Experience` + Senior + \n           `Job Title`, data = training)\nsummary(step_fit)\n```\n\nUnfortunately, Rsq remained nearly the same. However, one saving grace of the tune is that we were able to slightly reduce residual standard error and increase our F-statistic, so it may not look like it at first glance, but the model is still stronger than our initial attempt, even if only slightly.\n\nNow that we've tuned our model, let us visualize the predictions.\n\nThis first plot depicts the average predicted value of Salary at each age in the data.\n\n```{r}\neffect_plot(step_fit, pred = Age)\n```\n\nAs we can see, this shows a very strong correlation between salary and age.\n\nThis second plot once again depicts salary vs age, but this time plots the residual values along with showing the confidence interval of which the model operates. We can see most of our residuals lie within the interval, although there are a few outliers at both ends.\n\n```{r}\neffect_plot(step_fit, pred = Age, interval = TRUE, partial.residuals = TRUE)\n```\n\n## Tree Methods:\n\nFor our second model, we want to use the power of Tree methods to see if it could give us a better answer to our main question than multiple linear regression. We will be mainly focusing on the Decision Tree method, but we will also create a Random Forest tree for comparison.\n\n### Decision Tree:\n\nAs we learned from class, we know that decision trees can mirror human decision-making more than other methods. We want to try to put this to the test to create a decision tree model based on our salary data to see if it can accurately predict an employee's salary using binary decision-making.\n\nTo begin, we will make an untidy decision tree to visualize the decision-making process the model will take to determine salary.\n\n```{r}\n# Non-tidy way (for visualization purposes)\ntree_fit <- rpart(Salary ~., data = train)\n\nrpart.plot(tree_fit)\n```\n\nWe can see from this output that Years of Experience and job titles are very influential in decision-making. To be able to print this tree without having tens of job names crowd out the actual Boolean expression, we coded the job title to be a numeric value and factorized it, so while it's a bit harder to understand what is happening, the lower a job title's value is, the less money the position makes. Back to the tree, we can see that the longer someone works, the more money they will earn, and there are no questions about what position they will hold; they will still earn more money due to their experience. However, when we go down the tree in the opposite direction (meaning an employee has less experience), their position starts to play a more pivotal role.\n\nBelow we can see the decision tree model fitted onto the testing data. We can also see the predicted values compared to the actual salary values.\n\n```{r}\ntree_fit_2 <- rpart(Salary ~., data = training)\ntree_preds <- predict(tree_fit_2, newdata = testing) %>%\n  bind_cols(testing)\ntree_preds\n```\n\nWhile the predictions appear to be fairly accurate to the actual values, we can see that the model is not good at predicting small changes within similar records. Therefore, we need to tune for it to factor in these smaller changes into the data.\n\n```{r}\n# Tidy way + tuning   \ntree_model <- decision_tree(mode = \"regression\",\n                            cost_complexity = tune(),\n                            tree_depth = tune()) %>%\n  set_engine(\"rpart\")\n\n\ndata_recipe <- recipe(Salary ~., training)\n\nwf <- workflow() %>%\n  add_recipe(data_recipe) %>%\n  add_model(tree_model)\n\ntree_grid <- grid_regular(cost_complexity(),\n                          tree_depth(),\n                          levels = 5)\n\ncv_samples <- vfold_cv(training)\n\ntree_tune <- wf %>%\n  tune_grid(\n    resamples = cv_samples,\n    grid = tree_grid\n  )\n\nbest_tree <- tree_tune %>%\n  select_best(metric = \"rmse\")\n\nfinal_wf <- wf %>%\n  finalize_workflow(best_tree)\n  \n\nfinal_wf %>%\n  last_fit(salary_split) %>%\n  collect_metrics() \n\ntuned_tree_preds <- final_wf %>%\n  last_fit(salary_split) %>%\n  collect_predictions() %>%\n  bind_cols(testing)\n```\n\nAs we can see from the output of the tuned decision tree above, we get an r-squared value of .958, which is an incredible accuracy considering decision trees often suffer from low predictive power. However, our RMSE value is at a staggering 10491.67, so our outliers are heavily impacting the model in a negative way, which is usually the case for Decision Trees.\n\n```{r}\ntuned_tree_preds\n```\n\nLooking at our predicted values now, we can see that the model is way more accurate at factoring in slight differences between similar employees. Overall, this tuned regression decision tree does a really good job of making accurate predictions.\n\n### Random Forest Tree:\n\nFor comparison, let us look at this Random Forest Tree\n\n```{r}\nrf_model <- rand_forest() %>% \n    set_engine(\"ranger\") %>% \n    set_mode(\"regression\")\n\n# workflow\nrf_wf <- workflow() %>% \n    add_model(rf_model) %>% \n    add_recipe(data_recipe)\n\n# fit the regression tree\nrf_fit <- rf_wf %>% fit(training)\n\n# predict\ntesting$pred <- predict(rf_fit, testing)$.pred\n\n# metrics\ntesting %>% metrics(Salary, pred)\n\n\n```\n\nThe Random Forest tree did ever so slightly worse than the tuned decision tree model, but it still is very accurate at predicting salary.\n\n## Ridge Regression:\n\nWe chose ridge regression as our final model in the hopes that we could reduce the high amount of variance in our data to create an even more accurate model than our tuned Decision Tree.\n\nLet us start with a ridge model that we manually assign the penalties for. Let us use a manual penalty of 4 for the estimate. We must also center and scale all of our predictors to standardize them before we fit the model.\n\n```{r}\nridge_recipe <- recipe(Salary ~ ., data = train) %>%\n  step_center(all_nominal_predictors()) %>%\n  step_scale(all_nominal_predictors())\n\n\nridge_model <- linear_reg(mixture = 0, penalty = .1) %>%\n  set_engine(\"glmnet\")\n\nridge_wf <- workflow() %>%\n  add_recipe(ridge_recipe) %>%\n  add_model(ridge_model) %>%\n  fit(train)\nextract_fit_parsnip(ridge_wf) %>% tidy(penalty = 4)\n```\n\nFrom the output of the model, we can tell that it is not very accurate at all. The estimated values are extremely far away from zero.\n\nNow, let us try tuning the model to see if we can improve the accuracy of the ridge regression.\n\n```{r}\n## TUNING\nfolds <-vfold_cv(train)\n\nmodel <- linear_reg(mixture = 0, penalty = tune()) %>%\n  set_engine(\"glmnet\")\n\ntuned_wf <- workflow() %>%\n  add_recipe(ridge_recipe) %>%\n  add_model(ridge_model)\n\nridge_grid <- grid_regular(mixture(), penalty(), levels = 10)\n\ntuned_grid <- tune_grid(tuned_wf, resamples = folds, grid = ridge_grid)\ntuned_grid %>% collect_metrics() %>% filter(.metric == \"rmse\") %>% arrange(mean)\n```\n\nThe RMSE is almost three times larger than our decision tree model. It appears this model is not accurate at all at predicting salary.\n\nBefore we make any assumptions, let us take a look at the predictions\n\n```{r}\ntuned_grid %>% \n    select_best() %>% \n    finalize_workflow(tuned_wf, .) %>% \n    last_fit(ridge_split) %>% \n    collect_predictions()\n```\n\nOur tuned ridge regression model overestimates salary for every employee. It is now safe to say that this model is the least accurate out of the three that we have created today.\n\n# Comparison:\n\nTo compare our models, our decision tree by far did the best, as we have previously stated, but our multiple linear regression model was still respectable, being able to predict accurately within 82% of the data. Now for the ridge regression model. Our ridge regression model was not accurate even after being scaled, centered, and tuned. We are led to believe that this may have been due to the extremely large variance within the dataset.\n\n# Conclusion:\n\nIn conclusion, we were able to answer all of our questions after analyzing and modeling the data.\n\nStarting with our minor questions:\n\n-   Women do, in fact, get paid less than men; while men do have lower-paying jobs than women, on average their jobs are likely to pay less than a man's.\n\n-   Age does play a large role in how much an employee earns. experience and age go hand in hand with one another, as you are going to gain experience as you age (unless you are unemployed or start work later than the average person). Still, being older in your field almost certainly leads to better pay. We did find, however, that 60-year-olds make about the same as 50-year-olds do on average. So do not anticipate a pay raise heading into your pre-retirement years\n\n-   Having a senior-level position does indeed lead to a pay increase on average, and while we found a handful of outliers under 30, most employees in a senior-level position were older than this mark.\n\n-   Having a higher level of education does lead to a higher salary, and quite significantly so. We would hope this would be the case considering the amount of time and resources it takes to get each higher level of education.\n\n-   No, you do not need to move to another country to get a better wage. While there may be other reasons (such as benefits) to entice you to move abroad, salary should not be one of them.\n\nTo finish off this project, let us answer our main question: Can we accurately predict the salary of an employee given the predictors from the dataset?\n\nThe answer to this question is yes. Using a tuned decision tree model we were able to achieve an accuracy of 95% on our testing data. The model is not entirely perfect, but it is certainly good for the fact that it is predicting using regression, which is extremely hard to achieve good accuracy for.\n\nTo say the accuracy of our decision tree was a surprise would be an understatement. Considering the relatively small amount of variables within the data set we thought we would not be able to accurately predict salary, so to create such an accurate model was a pleasant surprise for us.\n","srcMarkdownNoYaml":"\n\n```{r custom_theme, results = \"hide\"}\nlibrary(tidyverse)\nstyled <-\n  theme_bw() + \n  theme(\n    plot.title = element_text(face = \"bold\", size = 12),\n    legend.background = element_rect(\n      fill = \"white\", \n      linewidth = 4, \n      colour = \"white\"\n    ),\n    axis.ticks = element_line(colour = \"grey70\", linewidth = 0.2),\n    panel.grid.major = element_line(colour = \"grey70\", linewidth = 0.2),\n    panel.grid.minor = element_blank()\n  )\n```\n\n```{r packages, results = \"hide\"}\nlibrary(\"tidymodels\") ; theme_set(styled)\nlibrary(\"janitor\")\nlibrary(\"olsrr\")\nlibrary(\"doParallel\")\nlibrary(\"dplyr\")\nlibrary(\"kernlab\")\nlibrary(\"rpart.plot\")\nlibrary(\"glmnet\")\nlibrary(\"GGally\")\nlibrary(\"cowplot\")\nlibrary(\"jtools\")\nlibrary(\"caret\")\n```\n\n```{r cores}\nall_cores <- parallel::detectCores(logical = FALSE)\ncl <- makePSOCKcluster(all_cores)\nregisterDoParallel(cl)\n```\n\n## Introduction:\n\nFor our Final Project, the dataset we decided to use was titled Salary by Job Title and Country. We found the dataset from Kaggle.com.\n\n<https://www.kaggle.com/datasets/amirmahdiabbootalebi/salary-by-job-title-and-country/data>\n\nThe dataset creator sourced this data from reputable employment websites and surveys, leaving out names and companies to ensure privacy for both parties.\n\n```{r dataset}\nSalary <- read_csv(\"Salary.csv\")\n```\n\nThere are 9 variables in the data, with 6684 observations. The variables are as follows: Age, Gender, Education Level, Job Title, Years of Experience, Salary, Country, Race, and Senior. Education level is encoded from 0-3, 0 meaning the employee has a high school diploma as their highest level of education, 1 meaning that they have a Bachelor's degree, 2 meaning they have a Master's, and 3 meaning they have a Doctorate's. The senior variable is a binary value indicating whether or not they have a senior-level position. Salary has been converted into USD for all countries for the sake of being on the same scale.\n\n```{r}\nhead(Salary)\n```\n\n# Questions and Goals:\n\nOur main question we wanted to answer was \"Can we accurately predict the salary of a job given the predictors in this data set\", those being Age, Senior, Country, Race, Job Title, Gender, and Education Level. We also wanted to explore the roles each of the predictors play in determining Salary. Some secondary questions we asked to determine this during our EDA were: \"Is one gender more often lower-paid than another?\", \"Does an increase in age usually lead to an increase in salary?\", \"How big a difference does a job being a senior position make on average to Salary?\", and more to go along with that: \"Are older people more likely to be the ones occupying senior positions?\". Whether or not the Education Level or Country of the job seems to give access to a higher salary were also questions we asked and found answers to.\n\n# **Preprocessing:**\n\nFor preprocessing, we quickly found 2 issues: First, we realized that certain job titles only appear once in the entire data set, one of the most notable being CEO. While this had one of the largest values for salary in the entire dataset, we realized that this would not only skew our EDA but would also cause problems for our testing and training splits later on. Therefore, we decided to drop them.\n\nWe then found an issue with values that were likely misreported within the dataset. Upon analyzing the bottom-most values for annual salary in the dataset, we found multiple employees reported only making 3 figures with jobs that in every other case paid well above that, such as Software Engineer Manager. We could be making a large assumption here that this was a full-time position being paid a yearly salary, but even if these values were correctly recorded, it would still be inconsistent with the rest of the dataset and cause a skew in the lowest-paying jobs.\n\n```{r}\n##PREPROCESSING\n\n#removing any job only included once \nSalary_cleaned <- Salary %>%\n  group_by(`Job Title`) %>%\n  mutate(\n    count = n()\n  ) %>%\n  filter(count > 1) %>%\n  ungroup() %>%\n  select(-count)\n#dropping probable mistaken entries (reported less than 1k salaries)\nSalary_cleaned <- Salary_cleaned %>%\n  arrange(Salary) %>%\n  filter(!row_number() %in% c(1,2,3,4))\n```\n\n# **EDA:**\n\n## Exploring Gender:\n\nWe wanted to explore if Females still earned less than men on average, as they have historically, so we first looked at a general average of all salaries of men versus those of women.\n\n```{r}\n#EDA (Gender)\n\n##GENDER DIFFERENCES\nSalary_cleaned_by_gender <- Salary_cleaned %>%\n  group_by(Gender) %>%\n    summarize(Mean = mean(Salary, na.rm = TRUE))\n#On average, women earn less than men\n\nSalary_cleaned_by_gender\n```\n\nThis table shows a sizable difference (about 19000) in the average salary of a male over one of a female, supporting our initial theory. We then split up the data to more deeply delve into the differences in pay between the two Genders.\n\n```{r}\n#Splitting salary into male and female\nsalary_male <- Salary_cleaned %>%\n  group_by(Gender) %>%\n    filter(Gender == \"Male\")\n\nsalary_female <- Salary_cleaned %>%\n  group_by(Gender) %>%\n    filter(Gender == \"Female\")\n```\n\nAfter splitting the data, we tried making four plots showing the top 15 highest-salary jobs and the bottom 15 lowest-salary jobs for comparison.\n\n```{r}\n# #comparing highest/lowest earning male/female jobs\n#  top_male_salaries <- salary_male %>%\n#  arrange(desc(Salary)) %>%\n#    slice(1:15)\n#  \n#  #ignoring mistaken entries (1 and 2 row)\n#  bottom_male_salaries <- salary_male %>%\n#  arrange(Salary) %>%\n#    slice(3:17)\n#  \n#  top_female_salaries <- salary_female %>%\n#  arrange(desc(Salary)) %>%\n#  slice(1:15)\n#  \n# #ignoring mistaken entries (1 and 2 row)\n#  bottom_female_salaries <- salary_female %>%\n#  arrange(Salary) %>%\n#    slice(3:17)\n\n#plots\n#tms_plot <- ggplot(top_male_salaries, aes(x = Salary)) +       #geom_bar(fill = \"blue\") +\n#theme_light()\n\n#bms_plot <- ggplot(bottom_male_salaries, aes(x = Salary)) +\n# geom_bar(fill = \"turquoise2\") +\n# theme_dark()\n\n#the above plots don't look good...\n#they are mostly the same jobs\n\n#trying again but with...\n```\n\nthe above plots don't look good... they are mostly the same jobs trying again but with averaging jobs with the same title together.\n\nUpon making the first few plots, we realized that the above plots did not look good as they were mostly showing the same job titles' salaries repeated multiple times. We remade the graphs but this time combined the job titles to eliminate repeated Job Titles. First, we made new tables to use with a new Average_Salary column for each job title, then eliminated other columns and rows besides unique Average_Salaries and Job Titles since those were what we were focusing on.\n\n```{r}\n#averaging jobs with the same title together\nsalary_male_unique <- salary_male %>%\n  group_by(`Job Title`) %>%\n  mutate(Average_Salary = mean(Salary)) %>%\n  distinct(Average_Salary)\n  \nsalary_female_unique <- salary_female %>%\n  group_by(`Job Title`) %>%\n  mutate(Average_Salary = mean(Salary)) %>%\n  distinct(Average_Salary)\n\nsalary_male_unique\nsalary_female_unique\n```\n\n```{r}\n#comparing highest/lowest earning male/female jobs\ntop_male_salaries_unique <- \n  salary_male_unique %>%\n  ungroup() %>% arrange(desc(Average_Salary)) %>% slice(1:10)\n\nbottom_male_salaries_unique <- \n  salary_male_unique %>%\n  ungroup() %>% \n  arrange(Average_Salary) %>% \n  slice(1:10)\n\ntop_female_salaries_unique <- \n  salary_female_unique %>%\n  ungroup() %>% \n  arrange(desc(Average_Salary)) %>% slice(1:10)\n\nbottom_female_salaries_unique <- \n  salary_female_unique %>%\n  ungroup %>%\n  arrange(Average_Salary) %>%\n    slice(1:10)\n\ntop_male_salaries_unique \nbottom_male_salaries_unique\ntop_female_salaries_unique\nbottom_female_salaries_unique\n```\n\nWe made the plots again, making sure to standardize the x-axis values to more clearly show any differences in pay. We made male plots blue, and female red, top salary plots have a light theme, and bottom salary plots use the dark theme to differentiate and help show the comparisons we were looking for.\n\n```{r}\ntms_plot <- ggplot(top_male_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"blue\") + \n    labs(y = \"Job Count\", x = \"Average Salary (Male)\") +\n    xlim(150000, 250000)\n```\n\n```{r}\nbms_plot <- ggplot(bottom_male_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"turquoise2\", bins = 40) +\n    labs(y = \"Job Count\", x = \"Average Salary (Male)\") +\n    xlim(24000, 58000)+ ylim(0, 3) + theme_dark()\n```\n\n```{r}\ntfs_plot <- ggplot(top_female_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"red\") +\n    labs(y = \"Job Count\", x = \"Average Salary (Female)\") +\n    xlim(150000, 250000)\n```\n\n```{r}\nbfs_plot <- ggplot(bottom_female_salaries_unique, aes(x = Average_Salary)) +\n    geom_histogram(fill = \"lightcoral\") +\n    labs(y = \"Job Count\", x = \"Average Salary (Female)\") +\n    xlim(24000, 58000) + ylim(0, 3) + theme_dark()\n```\n\nWe used the \"cowplot\" package to easily combine all four plots into one graphic for a more complete visual comparison of gender salary differences on the poles of the data.\n\n```{r}\nplot_grid(tms_plot, bms_plot, tfs_plot, bfs_plot, nrow = 2, ncol = 2)\n```\n\nAfter doing this, we realized that we could do almost the same thing, but in a broader sense (as well as faster), by just using a box plot.\n\n```{r}\n#comparing all salaries\nggplot(Salary_cleaned, aes(x = Salary, y = Gender)) +\n    geom_boxplot(aes(\n        fill = as.factor(`Gender`))) +\n    scale_color_manual(values = c(\"blue\", \"red\")) +\n    theme(legend.position = \"none\")\n```\n\nThe box plots, as well as the four plots prior, all point to what we had guessed which was that males do indeed earn higher salaries than females on average.\n\n## Exploring Education Level:\n\nNext, we examined the role education level played on salary amount. This time, we started with the general plot comparing all salaries grouped by Education Level, then moved on to showing the average salary of each Education Level after that.\n\n```{r}\n#EDA (Education Level)\n\nggplot(Salary_cleaned, aes(y = Salary,\n                           x = as.factor(`Education Level`),\n                           fill = as.factor(`Education Level`\n                                            )))+\n    scale_color_manual(values = c(\"red\", \"green\", \"yellow\", \"darkorchid3\")) +\n    labs(x = \"Education Level\") + \n    geom_boxplot() +\n    theme(legend.position = \"none\")\n\nsalary_by_ed_lvl <- Salary_cleaned %>%\n  group_by(`Education Level`) %>%\n  summarize(Mean = mean(Salary))\n\nggplot(salary_by_ed_lvl, aes(x = `Education Level`,\n                             y = Mean,\n                             fill = as.factor(\n                                 `Education Level`\n                                 ))) +\n    scale_color_manual(values = c(\"red\", \"green\", \"yellow\", \"darkorchid3\" )) + \n    labs(y = \"Mean Salary\") +\n    geom_col() +\n    theme(legend.position = \"none\")\n```\n\nWe were pleased to see not only that the data seemed to indicate that going to college is indeed still worth it, but that the data was nice and linear as well for both the raw and the average salary by education level comparisons.\n\n## Exploring Age and Seniority:\n\nAge and Seniority were two predictors we were especially excited to look at, and we had high expectations on the strength of the correlation between them and the salaries those of high age and in senior positions would hold. Once again, we showed a general plot using the raw salary data when compared with Age, this time using whether or not the job holder had the Senior status to determine the color of the plot point. After getting a nice-looking scatter plot from that (and being very happy with the color palette), we could see that there was some positive correlation between the age of a person, whether or not they would be in a senior position, and their salary. To get a slightly different perspective, we grouped the ages by decade and compared each Age Group's average salary to each other, and were once again satisfied to see a seemingly linear relationship between Age and Salary.\n\n```{r}\n#EDA (Age/Seniority)\nggplot(Salary_cleaned, aes(y = Salary, x = Age, color = as.factor(Senior))) +\n    scale_color_manual(values = c(\"ivory4\", \"goldenrod\"),\n                       labels = c(\"Non-Senior Position\", \n                                  \"Senior\")) +\n    labs(color = \"Seniority\") + geom_point()\n\nsalary_by_age <- Salary_cleaned %>%\n  mutate(Age_Group = case_when(\n    Age < 30 ~ \"29 & Younger\",\n    Age < 40 & Age >= 30 ~ \"30's\",\n    Age < 50 & Age >= 40 ~ \"40's\",\n    Age < 60 & Age >= 50 ~ \"50's\",\n    Age >= 60 ~ \"60 & Older\"\n  )) %>% \n  group_by(Age_Group) %>%\n  summarize(Average_Salary = mean(Salary))\n\nggplot(salary_by_age, aes(x = Age_Group,\n                          y = Average_Salary,\n                          fill = as.factor(Age_Group)),) +\n    scale_fill_manual(values = c(\"ivory4\",\"grey\",\n                                 \"lightgoldenrod2\",\n                                 \"goldenrod2\",\n                                 \"goldenrod3\")) +\n    geom_col() +\n    theme(legend.position = \"none\",\n                       panel.background = element_rect(fill = \"slategray3\")) +\n    labs(x = \"Age Group\", y = \"Average Salary\")\n```\n\n## Exploring Country and Race:\n\nThe first thing we did to look at Country and Race was to use multilevel grouping to get a better understanding of the demographics of the data. After noting the variety of Races in each Country, we proceeded to make a violin plot comparing the Salaries of those living in different Countries. That plot did not look great, so we reverted to using box plots for comparing Races' Salary earnings. The main takeaway we received from these two plots was that the Country and Race of a person do not seem to be significant factors in determining one's salary.\n\n```{r}\n#EDA (Country/Race)\nSalary_cleaned %>% \n  group_by(Country, Race) %>%\n  summarize(count = n())\n\nggplot(Salary_cleaned, aes(x = Salary, y = Country, fill = as.factor(Country))) + \n    scale_fill_manual(values = c(\"red\", \"white\", \"gold\", \"purple\", \"blue\")) +\n    geom_violin() +\n    theme(legend.position = \"none\")\n\nggplot(Salary_cleaned, aes(x = Salary, y = Race, color =  as.factor(Race))) +\n    geom_boxplot() +\n    theme(legend.position = \"none\")\n\n```\n\n## Exploring Job Title:\n\nWhen thinking of what to explore with Job Titles, we were at first a little unsure of what to compare, since there were so many unique Job Titles in the data. We ended up simply making a table of the top 10 highest-salary jobs and the \"top 10\" lowest-salary jobs.\n\n```{r}\n#EDA (Job Title)\n#hrm...\nsalary_by_job_title <- Salary_cleaned %>%\n  group_by(`Job Title`) %>%\n  mutate(Average_Salary = mean(Salary)) %>%\n  distinct(Average_Salary)\n\ntop_jobs <- salary_by_job_title %>%\n  ungroup() %>%\n  arrange(desc(Average_Salary)) %>%\n  slice(1:10)\n\nworst_jobs <- salary_by_job_title %>%\n  ungroup() %>%\n  arrange(Average_Salary) %>%\n  slice(1:10)\n\ntop_jobs\nworst_jobs\n```\n\nOne interesting thing that we could see from these tables is that Job Titles with \"Director\" and \"Engineer\" are featured frequently in the higher end of the Salary data. This could either be an insight into the types of jobs that give high Salaries, or the types of jobs that the data was scraped from. Either way, the wide range of names meant that job titles were most likely going to be largely ineffective as a predictor for our models.\n\n# Modeling:\n\nNow that we have gathered some insights about this data as well as having answered our minor questions from our exploratory analysis, we will use modeling to answer our main question.\n\nBefore we get into creating the models, we will split the salary dataset into a training and testing data frame, using a 90/10 proportion respectively.\n\n```{r}\nsalary_split <- initial_split(Salary_cleaned, prop = 0.90)\ntraining <-training(salary_split)\ntesting <- testing(salary_split)\n```\n\nTo create a ridge regression model, we need to turn all of our datasets into numeric factors. We will get to the ridge regression model later. This is simply up here for rendering reasons.\n\n```{r}\nridge_salary <- Salary_cleaned %>%\n  transform(.,\n                   Race = as.numeric(as.factor(Race)),\n                   Country = as.numeric(as.factor(Country)),\n                   `Job Title` = as.numeric(as.factor(`Job Title`)),\n                   Gender = as.numeric(as.factor(Gender)))\nridge_split <- initial_split(ridge_salary, prop = .90)\ntrain <- training(ridge_split)\ntest <- testing(ridge_split)\n\n```\n\n## Multiple Linear Regression:\n\nNow that we split the data into training and testing, we will create our first model: a multiple linear regression model. A multiple linear regression model is simple, yet it can still give a good benchmark for comparisons to our other models.\n\n```{r}\nfit <- lm(Salary ~ ., data = training)\nsummary(fit)\n```\n\nAs we can see, the most significant predictors are education level, years of experience, and senior, all of which make sense as it is logical that the more years of experience you have in a profession and the higher level of education you have, the more likely you are going to earn more money than someone who has less experience and a lesser degree. Seniority also makes sense as a senior-level position undoubtedly has more responsibilities than someone who isn't. However, we can see that several job title codes are good indicators. Jobs such as software engineer, research scientist, research director, product manager, and data scientist/analyst all appear to be very good predictors for our model. This may well be because there are simply more observations of these job titles in the data set, but all of these fields are certainly very highly-paying positions. Now, to look at the results. We can see that the model generated an R-squared value of .82, on an F-stat of 296.3, and a p-value of \\<2.2e-16, so needless to say, this is a respectable model; it is not perfect, but there is a strong positive correlation between the predictors and Salary.\n\nBefore we go any further, we should check the assumptions of our model to see if this dataset even can be fitted into a linear model.\n\n```{r}\npar(mfrow = c(2,2))\nplot(fit)\n```\n\nChecking the normal assumptions of linear regression, we can see that the data appears to fit to an acceptable level. The residuals vs. Fitted values graph is distributed mostly evenly from end to end, and the Q-Q Residuals plot, while both tails do slightly veer off the mean, they do at least mirror each other.\n\nNow let us fit this model into our testing data. As you can see, we bound the predicted outcomes onto the testing dataset so we can compare the predicted value to the employee's actual salary.\n\n```{r}\nlm_preds <- predict(fit, testing) %>%\n  bind_cols(testing)\nlm_preds\n```\n\nWhile the predictions are not perfect, the model does get rather close to predicting the salary of some employees, with some predictions getting even within 1000 dollars of the actual value. However, it is not perfect, so let's tune the model to see if we can improve the accuracy.\n\nLet us try to optimize the model by running a step-forward selection model to see what variables it would choose to use.\n\n```{r}\nols_step_forward_p(fit)\n```\n\nUnsurprisingly, the summary has chosen the variables that I had highlighted in the original model. Interestingly, this model scraps Gender, Race, and Country; it does not consider them strong enough to influence the model.\n\nNow that we've figured out the ideal variables for the model, let's create a new model to see if we can improve the accuracy by removing unnecessary predictors:\n\n```{r}\nstep_fit <- \n    lm(Salary ~ Age + `Education Level` +\n           `Years of Experience` + Senior + \n           `Job Title`, data = training)\nsummary(step_fit)\n```\n\nUnfortunately, Rsq remained nearly the same. However, one saving grace of the tune is that we were able to slightly reduce residual standard error and increase our F-statistic, so it may not look like it at first glance, but the model is still stronger than our initial attempt, even if only slightly.\n\nNow that we've tuned our model, let us visualize the predictions.\n\nThis first plot depicts the average predicted value of Salary at each age in the data.\n\n```{r}\neffect_plot(step_fit, pred = Age)\n```\n\nAs we can see, this shows a very strong correlation between salary and age.\n\nThis second plot once again depicts salary vs age, but this time plots the residual values along with showing the confidence interval of which the model operates. We can see most of our residuals lie within the interval, although there are a few outliers at both ends.\n\n```{r}\neffect_plot(step_fit, pred = Age, interval = TRUE, partial.residuals = TRUE)\n```\n\n## Tree Methods:\n\nFor our second model, we want to use the power of Tree methods to see if it could give us a better answer to our main question than multiple linear regression. We will be mainly focusing on the Decision Tree method, but we will also create a Random Forest tree for comparison.\n\n### Decision Tree:\n\nAs we learned from class, we know that decision trees can mirror human decision-making more than other methods. We want to try to put this to the test to create a decision tree model based on our salary data to see if it can accurately predict an employee's salary using binary decision-making.\n\nTo begin, we will make an untidy decision tree to visualize the decision-making process the model will take to determine salary.\n\n```{r}\n# Non-tidy way (for visualization purposes)\ntree_fit <- rpart(Salary ~., data = train)\n\nrpart.plot(tree_fit)\n```\n\nWe can see from this output that Years of Experience and job titles are very influential in decision-making. To be able to print this tree without having tens of job names crowd out the actual Boolean expression, we coded the job title to be a numeric value and factorized it, so while it's a bit harder to understand what is happening, the lower a job title's value is, the less money the position makes. Back to the tree, we can see that the longer someone works, the more money they will earn, and there are no questions about what position they will hold; they will still earn more money due to their experience. However, when we go down the tree in the opposite direction (meaning an employee has less experience), their position starts to play a more pivotal role.\n\nBelow we can see the decision tree model fitted onto the testing data. We can also see the predicted values compared to the actual salary values.\n\n```{r}\ntree_fit_2 <- rpart(Salary ~., data = training)\ntree_preds <- predict(tree_fit_2, newdata = testing) %>%\n  bind_cols(testing)\ntree_preds\n```\n\nWhile the predictions appear to be fairly accurate to the actual values, we can see that the model is not good at predicting small changes within similar records. Therefore, we need to tune for it to factor in these smaller changes into the data.\n\n```{r}\n# Tidy way + tuning   \ntree_model <- decision_tree(mode = \"regression\",\n                            cost_complexity = tune(),\n                            tree_depth = tune()) %>%\n  set_engine(\"rpart\")\n\n\ndata_recipe <- recipe(Salary ~., training)\n\nwf <- workflow() %>%\n  add_recipe(data_recipe) %>%\n  add_model(tree_model)\n\ntree_grid <- grid_regular(cost_complexity(),\n                          tree_depth(),\n                          levels = 5)\n\ncv_samples <- vfold_cv(training)\n\ntree_tune <- wf %>%\n  tune_grid(\n    resamples = cv_samples,\n    grid = tree_grid\n  )\n\nbest_tree <- tree_tune %>%\n  select_best(metric = \"rmse\")\n\nfinal_wf <- wf %>%\n  finalize_workflow(best_tree)\n  \n\nfinal_wf %>%\n  last_fit(salary_split) %>%\n  collect_metrics() \n\ntuned_tree_preds <- final_wf %>%\n  last_fit(salary_split) %>%\n  collect_predictions() %>%\n  bind_cols(testing)\n```\n\nAs we can see from the output of the tuned decision tree above, we get an r-squared value of .958, which is an incredible accuracy considering decision trees often suffer from low predictive power. However, our RMSE value is at a staggering 10491.67, so our outliers are heavily impacting the model in a negative way, which is usually the case for Decision Trees.\n\n```{r}\ntuned_tree_preds\n```\n\nLooking at our predicted values now, we can see that the model is way more accurate at factoring in slight differences between similar employees. Overall, this tuned regression decision tree does a really good job of making accurate predictions.\n\n### Random Forest Tree:\n\nFor comparison, let us look at this Random Forest Tree\n\n```{r}\nrf_model <- rand_forest() %>% \n    set_engine(\"ranger\") %>% \n    set_mode(\"regression\")\n\n# workflow\nrf_wf <- workflow() %>% \n    add_model(rf_model) %>% \n    add_recipe(data_recipe)\n\n# fit the regression tree\nrf_fit <- rf_wf %>% fit(training)\n\n# predict\ntesting$pred <- predict(rf_fit, testing)$.pred\n\n# metrics\ntesting %>% metrics(Salary, pred)\n\n\n```\n\nThe Random Forest tree did ever so slightly worse than the tuned decision tree model, but it still is very accurate at predicting salary.\n\n## Ridge Regression:\n\nWe chose ridge regression as our final model in the hopes that we could reduce the high amount of variance in our data to create an even more accurate model than our tuned Decision Tree.\n\nLet us start with a ridge model that we manually assign the penalties for. Let us use a manual penalty of 4 for the estimate. We must also center and scale all of our predictors to standardize them before we fit the model.\n\n```{r}\nridge_recipe <- recipe(Salary ~ ., data = train) %>%\n  step_center(all_nominal_predictors()) %>%\n  step_scale(all_nominal_predictors())\n\n\nridge_model <- linear_reg(mixture = 0, penalty = .1) %>%\n  set_engine(\"glmnet\")\n\nridge_wf <- workflow() %>%\n  add_recipe(ridge_recipe) %>%\n  add_model(ridge_model) %>%\n  fit(train)\nextract_fit_parsnip(ridge_wf) %>% tidy(penalty = 4)\n```\n\nFrom the output of the model, we can tell that it is not very accurate at all. The estimated values are extremely far away from zero.\n\nNow, let us try tuning the model to see if we can improve the accuracy of the ridge regression.\n\n```{r}\n## TUNING\nfolds <-vfold_cv(train)\n\nmodel <- linear_reg(mixture = 0, penalty = tune()) %>%\n  set_engine(\"glmnet\")\n\ntuned_wf <- workflow() %>%\n  add_recipe(ridge_recipe) %>%\n  add_model(ridge_model)\n\nridge_grid <- grid_regular(mixture(), penalty(), levels = 10)\n\ntuned_grid <- tune_grid(tuned_wf, resamples = folds, grid = ridge_grid)\ntuned_grid %>% collect_metrics() %>% filter(.metric == \"rmse\") %>% arrange(mean)\n```\n\nThe RMSE is almost three times larger than our decision tree model. It appears this model is not accurate at all at predicting salary.\n\nBefore we make any assumptions, let us take a look at the predictions\n\n```{r}\ntuned_grid %>% \n    select_best() %>% \n    finalize_workflow(tuned_wf, .) %>% \n    last_fit(ridge_split) %>% \n    collect_predictions()\n```\n\nOur tuned ridge regression model overestimates salary for every employee. It is now safe to say that this model is the least accurate out of the three that we have created today.\n\n# Comparison:\n\nTo compare our models, our decision tree by far did the best, as we have previously stated, but our multiple linear regression model was still respectable, being able to predict accurately within 82% of the data. Now for the ridge regression model. Our ridge regression model was not accurate even after being scaled, centered, and tuned. We are led to believe that this may have been due to the extremely large variance within the dataset.\n\n# Conclusion:\n\nIn conclusion, we were able to answer all of our questions after analyzing and modeling the data.\n\nStarting with our minor questions:\n\n-   Women do, in fact, get paid less than men; while men do have lower-paying jobs than women, on average their jobs are likely to pay less than a man's.\n\n-   Age does play a large role in how much an employee earns. experience and age go hand in hand with one another, as you are going to gain experience as you age (unless you are unemployed or start work later than the average person). Still, being older in your field almost certainly leads to better pay. We did find, however, that 60-year-olds make about the same as 50-year-olds do on average. So do not anticipate a pay raise heading into your pre-retirement years\n\n-   Having a senior-level position does indeed lead to a pay increase on average, and while we found a handful of outliers under 30, most employees in a senior-level position were older than this mark.\n\n-   Having a higher level of education does lead to a higher salary, and quite significantly so. We would hope this would be the case considering the amount of time and resources it takes to get each higher level of education.\n\n-   No, you do not need to move to another country to get a better wage. While there may be other reasons (such as benefits) to entice you to move abroad, salary should not be one of them.\n\nTo finish off this project, let us answer our main question: Can we accurately predict the salary of an employee given the predictors from the dataset?\n\nThe answer to this question is yes. Using a tuned decision tree model we were able to achieve an accuracy of 95% on our testing data. The model is not entirely perfect, but it is certainly good for the fact that it is predicting using regression, which is extremely hard to achieve good accuracy for.\n\nTo say the accuracy of our decision tree was a surprise would be an understatement. Considering the relatively small amount of variables within the data set we thought we would not be able to accurately predict salary, so to create such an accurate model was a pleasant surprise for us.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"Final Project.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","title":"Final Project: Data Science Culmination Project","author":"Josh Miller & Elijah Hill"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":[]}